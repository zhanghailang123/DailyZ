装饰器模式可以解决类爆炸的问题吗？

利用继承无法解决类爆炸的问题

装饰器模式时继承的一个替代模式 （怎么理解这句话呢）

装饰器仍然继承自父接口，这里的继承是为了达到“类型”匹配的目的，而不是利用继承获得“行为”。


java.io 类
inputStream 是典型的装饰模式的应用。


所以我们选择装饰器模式

- 装饰者和被装饰对象有相同的父类或者接口
- 可以使用一个或多个装饰者包装一个对象
- 对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象



装饰器模式**完全遵循开放关闭原则**

通常情况下，我们无法让每个部分的设计都满足开发-关闭原则，
遵循开放-关闭原则 通常会引入新的抽象层次，增加代码的复杂度

上述所说其实就是代码的可维护性及代码的复杂度之间的权衡
往往增加抽象层次诚然可以增加可维护性，但是代码的复杂度也会增加

看一个例子
    假设这里有一个报价 IQuotation接口类，定义了一个calculate()方法用于计算对应报价的
账单的价格 所有的合同报价实现均需要实现这个类

    问题在于随着业务的增长，合同的报价越来越复杂，子类会爆炸


第一版解决想法
    
把新增报价有些东西转换为父类的属性



在父类calculate中计算基本报价的金额，而子类可以通过覆盖cost()方法会拓展父类的功能
把制定特殊报价的价钱也加进来

